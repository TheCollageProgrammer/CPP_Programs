// Let me explain both versions step by step — your factorial-based version and the optimized one — so you understand exactly how they work.

// 🧩 1️⃣ Your Factorial-based Version (using nCr formula)
// 🔹 Concept:

// In Pascal’s triangle, each element of the row can be calculated by nCr:

// 𝑛
// 𝐶
// 𝑟
// =
// 𝑛
// !
// 𝑟
// !
// ×
// (
// 𝑛
// −
// 𝑟
// )
// !
// nCr=
// r!×(n−r)!
// n!
// 	​


// Where:

// n = row index

// r = column index (0 to n)

// Example:
// For n = 3
// You get →
// C(3,0), C(3,1), C(3,2), C(3,3)
// = 1, 3, 3, 1

// 🔹 Code Flow (your version inside the class)
// vector<int> getRow(int rowIndex) {
//     vector<int> row;
//     for (int j = 0; j <= rowIndex; j++) {
//         row.push_back(ncr(rowIndex, j));
//     }
//     return row;
// }


// Step-by-step (for n = 3):

// j = 0 → ncr(3,0) = 1

// j = 1 → ncr(3,1) = 3

// j = 2 → ncr(3,2) = 3

// j = 3 → ncr(3,3) = 1
// 👉 So, row = [1, 3, 3, 1]

// Problem:
// For large n (like n = 30 or more), factorial values become huge and may overflow int.

// ⚡ 2️⃣ Optimized Version (without using factorials)

// We can calculate the row iteratively, using the property:

// 𝐶
// (
// 𝑛
// ,
// 𝑘
// )
// =
// 𝐶
// (
// 𝑛
// ,
// 𝑘
// −
// 1
// )
// ×
// (
// 𝑛
// −
// 𝑘
// +
// 1
// )
// 𝑘
// C(n,k)=C(n,k−1)×
// k
// (n−k+1)
// 	​


// This means you can build the row element-by-element using the previous one.

// 🔹 Example for n = 3:

// Start with C(3,0) = 1

// Then:

// C(3,1) = 1 * (3 - 1 + 1)/1 = 3

// C(3,2) = 3 * (3 - 2 + 1)/2 = 3

// C(3,3) = 3 * (3 - 3 + 1)/3 = 1

// ✅ Row = [1, 3, 3, 1]

// 🔹 Code:
// vector<int> getRow(int rowIndex) {
//     vector<int> row(rowIndex + 1, 1);
//     for (int i = 1; i < rowIndex; i++) {
//         row[i] = (long long)row[i - 1] * (rowIndex - i + 1) / i;
//     }
//     return row;
// }


// Explanation:

// We initialize the whole vector with 1s.

// Then for each position, calculate the next combination from the previous one.

// Using (long long) ensures no overflow during multiplication/division.

// 🔹 Advantages:

// ✅ No factorials → no overflow for big numbers
// ✅ Much faster (O(n) instead of O(n³))
// ✅ Uses only integer arithmetic

// If you want, I can show a dry-run table for rowIndex = 5 to see exactly how the optimized formula builds [1, 5, 10, 10, 5, 1].
// Would you like that?S