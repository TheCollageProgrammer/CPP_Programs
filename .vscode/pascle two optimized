// Let me explain both versions step by step â€” your factorial-based version and the optimized one â€” so you understand exactly how they work.

// ğŸ§© 1ï¸âƒ£ Your Factorial-based Version (using nCr formula)
// ğŸ”¹ Concept:

// In Pascalâ€™s triangle, each element of the row can be calculated by nCr:

// ğ‘›
// ğ¶
// ğ‘Ÿ
// =
// ğ‘›
// !
// ğ‘Ÿ
// !
// Ã—
// (
// ğ‘›
// âˆ’
// ğ‘Ÿ
// )
// !
// nCr=
// r!Ã—(nâˆ’r)!
// n!
// 	â€‹


// Where:

// n = row index

// r = column index (0 to n)

// Example:
// For n = 3
// You get â†’
// C(3,0), C(3,1), C(3,2), C(3,3)
// = 1, 3, 3, 1

// ğŸ”¹ Code Flow (your version inside the class)
// vector<int> getRow(int rowIndex) {
//     vector<int> row;
//     for (int j = 0; j <= rowIndex; j++) {
//         row.push_back(ncr(rowIndex, j));
//     }
//     return row;
// }


// Step-by-step (for n = 3):

// j = 0 â†’ ncr(3,0) = 1

// j = 1 â†’ ncr(3,1) = 3

// j = 2 â†’ ncr(3,2) = 3

// j = 3 â†’ ncr(3,3) = 1
// ğŸ‘‰ So, row = [1, 3, 3, 1]

// Problem:
// For large n (like n = 30 or more), factorial values become huge and may overflow int.

// âš¡ 2ï¸âƒ£ Optimized Version (without using factorials)

// We can calculate the row iteratively, using the property:

// ğ¶
// (
// ğ‘›
// ,
// ğ‘˜
// )
// =
// ğ¶
// (
// ğ‘›
// ,
// ğ‘˜
// âˆ’
// 1
// )
// Ã—
// (
// ğ‘›
// âˆ’
// ğ‘˜
// +
// 1
// )
// ğ‘˜
// C(n,k)=C(n,kâˆ’1)Ã—
// k
// (nâˆ’k+1)
// 	â€‹


// This means you can build the row element-by-element using the previous one.

// ğŸ”¹ Example for n = 3:

// Start with C(3,0) = 1

// Then:

// C(3,1) = 1 * (3 - 1 + 1)/1 = 3

// C(3,2) = 3 * (3 - 2 + 1)/2 = 3

// C(3,3) = 3 * (3 - 3 + 1)/3 = 1

// âœ… Row = [1, 3, 3, 1]

// ğŸ”¹ Code:
// vector<int> getRow(int rowIndex) {
//     vector<int> row(rowIndex + 1, 1);
//     for (int i = 1; i < rowIndex; i++) {
//         row[i] = (long long)row[i - 1] * (rowIndex - i + 1) / i;
//     }
//     return row;
// }


// Explanation:

// We initialize the whole vector with 1s.

// Then for each position, calculate the next combination from the previous one.

// Using (long long) ensures no overflow during multiplication/division.

// ğŸ”¹ Advantages:

// âœ… No factorials â†’ no overflow for big numbers
// âœ… Much faster (O(n) instead of O(nÂ³))
// âœ… Uses only integer arithmetic

// If you want, I can show a dry-run table for rowIndex = 5 to see exactly how the optimized formula builds [1, 5, 10, 10, 5, 1].
// Would you like that?S